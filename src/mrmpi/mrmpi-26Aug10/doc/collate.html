<HTML>
<CENTER><A HREF = "http://www.cs.sandia.gov/~sjplimp/mapreduce.html">MapReduce-MPI WWW Site</A> - <A HREF = "Manual.html">MapReduce-MPI Documentation</A> 
</CENTER>




<HR>

<H3>MapReduce collate() method 
</H3>
<PRE>uint64_t MapReduce::collate(int (*myhash)(char *, int)) 
</PRE>
<P>This calls the collate() method of a MapReduce object, which
aggregates a KeyValue object across processors and converts it into a
KeyMultiValue object.  This method is exactly the same as performing
an <A HREF = "aggregate.html">aggregate()</A> followed by a
<A HREF = "convert.html">convert()</A>.  The method returns the total number of
unique key/value pairs in the KeyMultiValue object.
</P>
<P>The hash argument is used by the <A HREF = "aggregate.html">aggregate()</A> portion
of the operation and can be specified as NULL.  See the
<A HREF = "aggregate.html">aggregate()</A> doc page for details.
</P>
<P>Note that if your map operation does not produce duplicate keys, you
do not typically need to perform a collate().  Instead you can convert
a KeyValue object into a KeyMultiValue object directly via the
<A HREF = "clone.html">clone()</A> method, which requires no communication.  Or you
can pass it directly to another <A HREF = "map.html">map()</A> operation.  One
exception would be if your map operation produces a KeyValue object
which is highly imbalanced across processors.  The
<A HREF = "aggregate.html">aggregate()</A> portion of the operation should
redistribute the key/value pairs more evenly.
</P>
<P>This method is a parallel operation (<A HREF = "aggregate.html">aggregate()</A>),
followed by an on-processor operation (<A HREF = "convert.html">convert()</A>).
</P>
<HR>

<P><B>Related methods</B>: <A HREF = "aggregate.html">aggregate()</A>, <A HREF = "clone.html">clone</A>,
<A HREF = "collapse.html">collapse()</A>, <A HREF = "compress.html">compress()</A>,
<A HREF = "convert.html">convert()</A>
</P>
</HTML>
